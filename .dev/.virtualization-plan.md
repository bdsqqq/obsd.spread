# virtualization implementation plan

## problem
current render() creates ALL 16k+ card DOM elements upfront → 69+ second load time.

## solution
row-based virtualization using @tanstack/virtual. virtualize ROWS (not cards) because cards have variable heights based on line count.

---

## 1. dependencies

```bash
npm install @tanstack/virtual-core
```

note: use `virtual-core` (framework-agnostic), not `@tanstack/react-virtual`.

---

## 2. files to modify

### src/spread-view.ts
major rewrite of render architecture.

### styles.css
add row container styles, remove `content-visibility` hack.

---

## 3. height calculation

### constants (derive from current CSS)
```ts
// header: padding-top(8) + line-height(~22) + padding-bottom(8) + border(1) = 39px
const HEADER_HEIGHT = 39;

// preview: padding(12px top + bottom) = 24px
const PREVIEW_PADDING = 24;

// line-height: 1.5 * font-smaller (~13px) = ~19.5px, round to 20
const LINE_HEIGHT = 20;

// card chrome: border-radius adds no height, but border(1px * 2) = 2px
const CARD_BORDER = 2;
```

### formula
```ts
function computeCardHeight(lineCount: number, maxLines: number, showHeader: boolean): number {
  const headerHeight = showHeader ? HEADER_HEIGHT : 0;
  const contentLines = Math.min(lineCount, maxLines);
  const previewHeight = PREVIEW_PADDING + (contentLines * LINE_HEIGHT);
  return headerHeight + previewHeight + CARD_BORDER;
}
```

### row height
```ts
// tallest card in the row determines row height
const rowHeight = Math.max(...cardsInRow.map(c => c.height));
```

---

## 4. data structures

### preprocessed entry
```ts
interface ProcessedEntry {
  file: TFile;
  preview: string;        // pre-computed text (avoid async in render)
  lineCount: number;      // for height calc
  height: number;         // pre-computed pixel height
}
```

### row
```ts
interface VirtualRow {
  index: number;
  entries: ProcessedEntry[];
  height: number;         // max height of cards in row
}
```

---

## 5. DOM structure changes

### before (current)
```
scrollEl (from BasesView)
└── .spread-view-container
    └── .spread-view-cards (CSS grid, contains ALL cards)
        ├── .spread-card
        ├── .spread-card
        └── ... (16k cards)
```

### after (virtualized)
```
scrollEl (from BasesView) ← THIS is the scroll container for virtualizer
└── .spread-view-container
    └── .spread-virtual-content (relative positioned, height = totalSize)
        └── .spread-virtual-rows (absolute positioned at virtualizer offset)
            ├── .spread-row (CSS grid for one row of cards)
            │   ├── .spread-card
            │   └── .spread-card
            └── .spread-row
                └── ...
```

---

## 6. implementation steps

### step 1: add dependency
```bash
npm install @tanstack/virtual-core
```

### step 2: add constants to spread-view.ts
```ts
// at top of file, after imports
const CARD_MIN_WIDTH = 250;  // from CSS: minmax(250px, 1fr)
const CARD_GAP = 12;         // --size-4-3 ≈ 12px

const HEADER_HEIGHT = 39;
const PREVIEW_PADDING = 24;
const LINE_HEIGHT = 20;
const CARD_BORDER = 2;
```

### step 3: add preprocess method
new method to compute all heights upfront, avoiding async during scroll:
```ts
private async preprocessEntries(entries: { file?: TFile | null }[]): Promise<ProcessedEntry[]> {
  const results: ProcessedEntry[] = [];
  for (const entry of entries) {
    if (!entry.file || !(entry.file instanceof TFile)) continue;
    const preview = await this.getPreview(entry.file);
    const lineCount = preview.split('\n').length;
    const height = this.computeCardHeight(lineCount);
    results.push({ file: entry.file, preview, lineCount, height });
  }
  return results;
}
```

### step 4: add row grouping method
```ts
private groupIntoRows(entries: ProcessedEntry[], containerWidth: number): VirtualRow[] {
  const cardsPerRow = Math.max(1, Math.floor((containerWidth + CARD_GAP) / (CARD_MIN_WIDTH + CARD_GAP)));
  const rows: VirtualRow[] = [];
  
  for (let i = 0; i < entries.length; i += cardsPerRow) {
    const rowEntries = entries.slice(i, i + cardsPerRow);
    const rowHeight = Math.max(...rowEntries.map(e => e.height));
    rows.push({ index: rows.length, entries: rowEntries, height: rowHeight });
  }
  return rows;
}
```

### step 5: create virtualizer
```ts
import { Virtualizer, elementScroll } from '@tanstack/virtual-core';

// in class properties
private virtualizer: Virtualizer<HTMLElement, VirtualRow> | null = null;
private rows: VirtualRow[] = [];
private processedEntries: ProcessedEntry[] = [];

// in render method
private setupVirtualizer(scrollEl: HTMLElement, rows: VirtualRow[]): void {
  this.virtualizer = new Virtualizer({
    count: rows.length,
    getScrollElement: () => scrollEl,
    estimateSize: (index) => rows[index].height,
    overscan: 3,  // render 3 extra rows above/below viewport
    scrollToFn: elementScroll,
  });
  
  this.virtualizer.subscribe(() => this.renderVisibleRows());
}
```

### step 6: rewrite render() method
```ts
private async render(): Promise<void> {
  if (!this.data) return;
  
  const entries = this.data.data ?? [];
  // ... hash check ...
  
  // step A: preprocess all entries (async, one-time)
  this.processedEntries = await this.preprocessEntries(entries);
  
  // step B: get container width, group into rows
  const containerWidth = this.containerEl.clientWidth || 800;
  this.rows = this.groupIntoRows(this.processedEntries, containerWidth);
  
  // step C: setup DOM structure
  this.cardsEl.empty();
  this.cardsEl.className = 'spread-virtual-content';
  this.rowsEl = this.cardsEl.createDiv({ cls: 'spread-virtual-rows' });
  
  // step D: init virtualizer with scrollEl (passed from constructor)
  this.setupVirtualizer(this.scrollEl, this.rows);
  
  // step E: trigger initial render
  this.renderVisibleRows();
}
```

### step 7: add renderVisibleRows method
```ts
private renderVisibleRows(): void {
  if (!this.virtualizer) return;
  
  const virtualRows = this.virtualizer.getVirtualItems();
  const totalSize = this.virtualizer.getTotalSize();
  
  // set content height for scrollbar
  this.cardsEl.style.height = `${totalSize}px`;
  
  // position visible rows container
  const offset = virtualRows[0]?.start ?? 0;
  this.rowsEl.style.transform = `translateY(${offset}px)`;
  
  // render visible rows
  this.rowsEl.empty();
  for (const vRow of virtualRows) {
    const row = this.rows[vRow.index];
    const rowEl = this.createRowElement(row);
    rowEl.style.height = `${row.height}px`;
    this.rowsEl.appendChild(rowEl);
  }
}

private createRowElement(row: VirtualRow): HTMLElement {
  const rowEl = document.createElement('div');
  rowEl.className = 'spread-row';
  
  for (const entry of row.entries) {
    const cardEl = this.createCardSync(entry);
    cardEl.style.height = `${row.height}px`;  // all cards in row share height
    rowEl.appendChild(cardEl);
  }
  return rowEl;
}
```

### step 8: add synchronous card creation
```ts
// rename current createCard to createCardSync, use pre-computed preview
private createCardSync(entry: ProcessedEntry): HTMLElement {
  const cardEl = document.createElement('div');
  cardEl.className = 'spread-card';
  
  if (this.showFileName) {
    // ... header creation (same as current) ...
  }
  
  const previewEl = document.createElement('div');
  previewEl.className = 'spread-card-preview';
  if (this.monoFont) previewEl.classList.add('spread-card-mono');
  previewEl.textContent = entry.preview;  // use pre-computed
  cardEl.appendChild(previewEl);
  
  return cardEl;
}
```

### step 9: handle resize
```ts
// add to constructor or onload
private resizeObserver: ResizeObserver | null = null;

private setupResizeObserver(): void {
  this.resizeObserver = new ResizeObserver(() => {
    if (this.processedEntries.length > 0) {
      const containerWidth = this.containerEl.clientWidth;
      this.rows = this.groupIntoRows(this.processedEntries, containerWidth);
      // recreate virtualizer with new row heights
      this.setupVirtualizer(this.scrollEl, this.rows);
    }
  });
  this.resizeObserver.observe(this.containerEl);
}

// in onunload
if (this.resizeObserver) {
  this.resizeObserver.disconnect();
}
```

---

## 7. CSS changes

```css
/* remove from .spread-card */
/* content-visibility: auto; */
/* contain-intrinsic-size: 250px 180px; */

/* remove .spread-view-cards grid */

/* add new classes */
.spread-virtual-content {
  position: relative;
  width: 100%;
}

.spread-virtual-rows {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
}

.spread-row {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: var(--size-4-3);
  padding-bottom: var(--size-4-3);  /* gap between rows */
}

/* .spread-card stays mostly same, remove overflow: hidden if causing issues */
```

---

## 8. scroll container integration

critical: BasesView passes `scrollEl` to constructor. this is the actual scrollable element, NOT the container we create.

```ts
constructor(controller: QueryController, scrollEl: HTMLElement) {
  super(controller);
  this.scrollEl = scrollEl;  // STORE THIS - needed for virtualizer
  this.containerEl = scrollEl.createDiv({ cls: 'spread-view-container' });
  // ...
}
```

the virtualizer's `getScrollElement` must return this `scrollEl`, not `containerEl`.

---

## 9. testing checkpoints

1. **after step 1**: build succeeds with new dep
2. **after step 3**: log preprocessed entries count, verify heights
3. **after step 4**: log row count, verify grouping math
4. **after step 6**: verify DOM structure in devtools
5. **after step 7**: scroll and verify only ~10-15 rows in DOM at any time
6. **after step 9**: resize window, verify re-grouping

---

## 10. expected performance

- **initial load**: ~5-10 seconds (preprocessing 16k files, reading content)
- **scroll performance**: instant (only ~10-15 rows in DOM)
- **memory**: much lower (no 16k DOM nodes)

preprocessing could be further optimized with caching/incremental updates, but that's phase 2.
